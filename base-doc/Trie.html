<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="Array.html">Array</a></li></li><li><li><a href="AssocList.html">AssocList</a></li></li><li><li><a href="Blob.html">Blob</a></li></li><li><li><a href="Bool.html">Bool</a></li></li><li><li><a href="Buffer.html">Buffer</a></li></li><li><li><a href="CertifiedData.html">CertifiedData</a></li></li><li><li><a href="Char.html">Char</a></li></li><li><li><a href="Debug.html">Debug</a></li></li><li><li><a href="Deque.html">Deque</a></li></li><li><li><a href="Error.html">Error</a></li></li><li><li><a href="ExperimentalCycles.html">ExperimentalCycles</a></li></li><li><li><a href="ExperimentalInternetComputer.html">ExperimentalInternetComputer</a></li></li><li><li><a href="ExperimentalStableMemory.html">ExperimentalStableMemory</a></li></li><li><li><a href="Float.html">Float</a></li></li><li><li><a href="Func.html">Func</a></li></li><li><li><a href="Hash.html">Hash</a></li></li><li><li><a href="HashMap.html">HashMap</a></li></li><li><li><a href="Heap.html">Heap</a></li></li><li><li><a href="Int.html">Int</a></li></li><li><li><a href="Int16.html">Int16</a></li></li><li><li><a href="Int32.html">Int32</a></li></li><li><li><a href="Int64.html">Int64</a></li></li><li><li><a href="Int8.html">Int8</a></li></li><li><li><a href="Iter.html">Iter</a></li></li><li><li><a href="IterType.html">IterType</a></li></li><li><li><a href="List.html">List</a></li></li><li><li><a href="Nat.html">Nat</a></li></li><li><li><a href="Nat16.html">Nat16</a></li></li><li><li><a href="Nat32.html">Nat32</a></li></li><li><li><a href="Nat64.html">Nat64</a></li></li><li><li><a href="Nat8.html">Nat8</a></li></li><li><li><a href="None.html">None</a></li></li><li><li><a href="Option.html">Option</a></li></li><li><li><a href="Order.html">Order</a></li></li><li><li><a href="Prelude.html">Prelude</a></li></li><li><li><a href="Principal.html">Principal</a></li></li><li><li><a href="RBTree.html">RBTree</a></li></li><li><li><a href="Random.html">Random</a></li></li><li><li><a href="Result.html">Result</a></li></li><li><li><a href="Stack.html">Stack</a></li></li><li><li><a href="Text.html">Text</a></li></li><li><li><a href="Time.html">Time</a></li></li><li><li><a href="Trie.html">Trie</a></li></li><li><li><a href="TrieMap.html">TrieMap</a></li></li><li><li><a href="TrieSet.html">TrieSet</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Trie">Trie</a></li></li><li><li><a href="#type.Leaf">Leaf</a></li></li><li><li><a href="#type.Branch">Branch</a></li></li><li><li><a href="#type.AssocList">AssocList</a></li></li><li><li><a href="#type.Key">Key</a></li></li><li><li><a href="#equalKey">equalKey</a></li></li><li><li><a href="#isValid">isValid</a></li></li><li><li><a href="#type.Trie2D">Trie2D</a></li></li><li><li><a href="#type.Trie3D">Trie3D</a></li></li><li><li><a href="#empty">empty</a></li></li><li><li><a href="#size">size</a></li></li><li><li><a href="#branch">branch</a></li></li><li><li><a href="#leaf">leaf</a></li></li><li><li><a href="#fromList">fromList</a></li></li><li><li><a href="#clone">clone</a></li></li><li><li><a href="#replace">replace</a></li></li><li><li><a href="#put">put</a></li></li><li><li><a href="#get">get</a></li></li><li><li><a href="#find">find</a></li></li><li><li><a href="#merge">merge</a></li></li><li><li><a href="#mergeDisjoint">mergeDisjoint</a></li></li><li><li><a href="#diff">diff</a></li></li><li><li><a href="#disj">disj</a></li></li><li><li><a href="#join">join</a></li></li><li><li><a href="#foldUp">foldUp</a></li></li><li><li><a href="#prod">prod</a></li></li><li><li><a href="#iter">iter</a></li></li><li><li><a href="#Build">Build</a></li></li><li><li><a href="#fold">fold</a></li></li><li><li><a href="#some">some</a></li></li><li><li><a href="#all">all</a></li></li><li><li><a href="#nth">nth</a></li></li><li><li><a href="#toArray">toArray</a></li></li><li><li><a href="#isEmpty">isEmpty</a></li></li><li><li><a href="#filter">filter</a></li></li><li><li><a href="#mapFilter">mapFilter</a></li></li><li><li><a href="#equalStructure">equalStructure</a></li></li><li><li><a href="#replaceThen">replaceThen</a></li></li><li><li><a href="#putFresh">putFresh</a></li></li><li><li><a href="#put2D">put2D</a></li></li><li><li><a href="#put3D">put3D</a></li></li><li><li><a href="#remove">remove</a></li></li><li><li><a href="#removeThen">removeThen</a></li></li><li><li><a href="#remove2D">remove2D</a></li></li><li><li><a href="#remove3D">remove3D</a></li></li><li><li><a href="#mergeDisjoint2D">mergeDisjoint2D</a></li></li></ul></nav><div class="documentation"><h1>Trie</h1><p>Functional key-value hash maps.</p>
<p>Functional maps (and sets) whose representation is &quot;canonical&quot;, and
independent of operation history (unlike other popular search trees).</p>
<p>The representation we use here comes from Section 6 of <a href="https://dl.acm.org/citation.cfm?id=75305">&quot;Incremental computation via function caching&quot;, Pugh &amp; Teitelbaum</a>.</p>
<h2 id="User-39-s-overview">User's overview</h2>

<p>This module provides an applicative (functional) hash map.
Notably, each <code>put</code> produces a <strong>new trie <em>and value being replaced, if any</em></strong>.</p>
<p>Those looking for a more familiar (imperative,
object-oriented) hash map should consider <code>TrieMap</code> or <code>HashMap</code> instead.</p>
<p>The basic <code>Trie</code> operations consist of:</p>
<ul><li><code>put</code> - put a key-value into the trie, producing a new version.</li><li><code>get</code> - get a key's value from the trie, or <code>null</code> if none.</li><li><code>iter</code> - visit every key-value in the trie.</li></ul>

<p>The <code>put</code> and <code>get</code> operations work over <code>Key</code> records,
which group the hash of the key with its non-hash key value.</p>
<pre class="motoko"><code class="motoko">import Trie &quot;mo:base/Trie&quot;;
import Text &quot;mo:base/Text&quot;;

type Trie&lt;K, V&gt; = Trie.Trie&lt;K, V&gt;;
type Key&lt;K&gt; = Trie.Key&lt;K&gt;;

func key(t: Text) : Key&lt;Text&gt; { { key = t; hash = Text.hash t } };

let t0 : Trie&lt;Text, Nat&gt; = Trie.empty();
let t1 : Trie&lt;Text, Nat&gt; = Trie.put(t0, key &quot;hello&quot;, Text.equal, 42).0;
let t2 : Trie&lt;Text, Nat&gt; = Trie.put(t1, key &quot;world&quot;, Text.equal, 24).0;
let n : ?Nat = Trie.put(t1, key &quot;hello&quot;, Text.equal, 0).1;
assert (n == ?42);</code></pre><div class="declaration"><h4 class="type-declaration" id="type.Trie"><span class="keyword">type </span><span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; = {#empty; #leaf : <a href="#type.Leaf"><span class="type">Leaf</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;; #branch : <a href="#type.Branch"><span class="type">Branch</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;}</h4><p><p>Binary hash tries: either empty, a leaf node, or a branch node</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Leaf"><span class="keyword">type </span><span class="type">Leaf</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; = { size : <span class="type">Nat</span>; keyvals : <a href="#type.AssocList"><span class="type">AssocList</span></a>&lt;<a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt; }</h4><p><p>Leaf nodes of trie consist of key-value pairs as a list.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Branch"><span class="keyword">type </span><span class="type">Branch</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; = { size : <span class="type">Nat</span>; left : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;; right : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; }</h4><p><p>Branch nodes of the trie discriminate on a bit position of the keys' hashes.
we never store this bitpos; rather,
we enforce a style where this position is always known from context.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.AssocList"><span class="keyword">type </span><span class="type">AssocList</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; = <a href="AssocList.html#type.AssocList"><span class="type">AssocList.AssocList</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Key"><span class="keyword">type </span><span class="type">Key</span>&lt;<span class="type">K</span>&gt; = { hash : <a href="Hash.html#type.Hash"><span class="type">Hash.Hash</span></a>; key : <span class="type">K</span> }</h4><p></p></div><div class="declaration"><h4 class="function" id="equalKey"><code><span class="keyword">public func </span><span class="fnname">equalKey</span>&lt;<span class="type">K</span>&gt;(<span class="parameter">keq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>) : ((<a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;) -&gt; <span class="type">Bool</span>)</code></h4><p><p>Equality function for two <code>Key&lt;K&gt;</code>s, in terms of equality of <code>K</code>'s.</p>
</p></div><div class="declaration"><h4 class="function" id="isValid"><code><span class="keyword">public func </span><span class="fnname">isValid</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">_enforceNormal</span> : <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>@deprecated <code>isValid</code> is an internal predicate and will be removed in future.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Trie2D"><span class="keyword">type </span><span class="type">Trie2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt; = <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K1</span>, <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K2</span>, <span class="type">V</span>&gt;&gt;</h4><p><p>A 2D trie maps dimension-1 keys to another
layer of tries, each keyed on the dimension-2 keys.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Trie3D"><span class="keyword">type </span><span class="type">Trie3D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt; = <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K1</span>, <a href="#type.Trie2D"><span class="type">Trie2D</span></a>&lt;<span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;&gt;</h4><p><p>A 3D trie maps dimension-1 keys to another
layer of 2D tries, each keyed on the dimension-2 and dimension-3 keys.</p>
</p></div><div class="declaration"><h4 class="function" id="empty"><code><span class="keyword">public func </span><span class="fnname">empty</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;() : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>An empty trie.</p>
</p></div><div class="declaration"><h4 class="function" id="size"><code><span class="keyword">public func </span><span class="fnname">size</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <span class="type">Nat</span></code></h4><p><p> Get the number of key-value pairs in the trie, in constant time.
Get size in O(1) time.</p>
</p></div><div class="declaration"><h4 class="function" id="branch"><code><span class="keyword">public func </span><span class="fnname">branch</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">l</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">r</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Construct a branch node, computing the size stored there.</p>
</p></div><div class="declaration"><h4 class="function" id="leaf"><code><span class="keyword">public func </span><span class="fnname">leaf</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">kvs</span> : <a href="#type.AssocList"><span class="type">AssocList</span></a>&lt;<a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt;, <span class="parameter">bitpos</span> : <span class="type">Nat</span>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Construct a leaf node, computing the size stored there.</p>
<p>This helper function automatically enforces the MAX_LEAF_SIZE
by constructing branches as necessary; to do so, it also needs the bitpos
of the leaf.</p>
</p></div><div class="declaration"><h4 class="function" id="fromList"><code><span class="keyword">public func </span><span class="fnname">fromList</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">kvc</span> : ?<span class="type">Nat</span>, <br/>  <span class="parameter">kvs</span> : <a href="#type.AssocList"><span class="type">AssocList</span></a>&lt;<a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt;, <br/>  <span class="parameter">bitpos</span> : <span class="type">Nat</span><br/>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Transform a list into a trie, splitting input list into small (leaf) lists, if necessary.</p>
</p></div><div class="declaration"><h4 class="function" id="clone"><code><span class="keyword">public func </span><span class="fnname">clone</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Clone the trie efficiently, via sharing.</p>
<p>Purely-functional representation permits <em>O(1)</em> copy, via persistent sharing.</p>
</p></div><div class="declaration"><h4 class="function" id="replace"><code><span class="keyword">public func </span><span class="fnname">replace</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v</span> : ?<span class="type">V</span><br/>) : (<a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p><p>Replace the given key's value option with the given one, returning the previous one</p>
</p></div><div class="declaration"><h4 class="function" id="put"><code><span class="keyword">public func </span><span class="fnname">put</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v</span> : <span class="type">V</span><br/>) : (<a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p><p>Put the given key's value in the trie; return the new trie, and the previous value associated with the key, if any</p>
</p></div><div class="declaration"><h4 class="function" id="get"><code><span class="keyword">public func </span><span class="fnname">get</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span><br/>) : ?<span class="type">V</span></code></h4><p><p>Get the value of the given key in the trie, or return null if nonexistent</p>
</p></div><div class="declaration"><h4 class="function" id="find"><code><span class="keyword">public func </span><span class="fnname">find</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span><br/>) : ?<span class="type">V</span></code></h4><p><p>Find the given key's value in the trie, or return null if nonexistent</p>
</p></div><div class="declaration"><h4 class="function" id="merge"><code><span class="keyword">public func </span><span class="fnname">merge</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">tl</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span><br/>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Merge tries, preferring the left trie where there are collisions
in common keys.</p>
<p>note: the <code>disj</code> operation generalizes this <code>merge</code>
operation in various ways, and does not (in general) lose
information; this operation is a simpler, special case.</p>
</p></div><div class="declaration"><h4 class="function" id="mergeDisjoint"><code><span class="keyword">public func </span><span class="fnname">mergeDisjoint</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">tl</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span><br/>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Merge tries like <code>merge</code>, except signals a
dynamic error if there are collisions in common keys between the
left and right inputs.</p>
</p></div><div class="declaration"><h4 class="function" id="diff"><code><span class="keyword">public func </span><span class="fnname">diff</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">W</span>&gt;(<br/>  <span class="parameter">tl</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">W</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span><br/>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Difference of tries. The output consists are pairs of
the left trie whose keys are not present in the right trie; the
values of the right trie are irrelevant.</p>
</p></div><div class="declaration"><h4 class="function" id="disj"><code><span class="keyword">public func </span><span class="fnname">disj</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">W</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">tl</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">W</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">vbin</span> : (?<span class="type">V</span>, ?<span class="type">W</span>) -&gt; <span class="type">X</span><br/>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">X</span>&gt;</code></h4><p><p>Map disjunction.</p>
<p>This operation generalizes the notion of &quot;set union&quot; to finite maps.</p>
<p>Produces a &quot;disjunctive image&quot; of the two tries, where the values of
matching keys are combined with the given binary operator.</p>
<p>For unmatched key-value pairs, the operator is still applied to
create the value in the image.  To accomodate these various
situations, the operator accepts optional values, but is never
applied to (null, null).</p>
<p>Implements the database idea of an <a href="https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join">&quot;outer join&quot;</a>.</p>
</p></div><div class="declaration"><h4 class="function" id="join"><code><span class="keyword">public func </span><span class="fnname">join</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">W</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">tl</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">W</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">vbin</span> : (<span class="type">V</span>, <span class="type">W</span>) -&gt; <span class="type">X</span><br/>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">X</span>&gt;</code></h4><p><p>Map join.</p>
<p>Implements the database idea of an <a href="https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join">&quot;inner join&quot;</a>.</p>
<p>This operation generalizes the notion of &quot;set intersection&quot; to
finite maps.  The values of matching keys are combined with the given binary
operator, and unmatched key-value pairs are not present in the output.</p>
</p></div><div class="declaration"><h4 class="function" id="foldUp"><code><span class="keyword">public func </span><span class="fnname">foldUp</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">bin</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">X</span>, <br/>  <span class="parameter">leaf</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">X</span>, <br/>  <span class="parameter">empty</span> : <span class="type">X</span><br/>) : <span class="type">X</span></code></h4><p><p>This operation gives a recursor for the internal structure of
tries.  Many common operations are instantiations of this function,
either as clients, or as hand-specialized versions (e.g., see , map,
mapFilter, some and all below).</p>
</p></div><div class="declaration"><h4 class="function" id="prod"><code><span class="keyword">public func </span><span class="fnname">prod</span>&lt;<span class="type">K1</span>, <span class="type">V1</span>, <span class="type">K2</span>, <span class="type">V2</span>, <span class="type">K3</span>, <span class="type">V3</span>&gt;(<br/>  <span class="parameter">tl</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K1</span>, <span class="type">V1</span>&gt;, <br/>  <span class="parameter">tr</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K2</span>, <span class="type">V2</span>&gt;, <br/>  <span class="parameter">op</span> : (<span class="type">K1</span>, <span class="type">V1</span>, <span class="type">K2</span>, <span class="type">V2</span>) -&gt; ?(<a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K3</span>&gt;, <span class="type">V3</span>), <br/>  <span class="parameter">k3_eq</span> : (<span class="type">K3</span>, <span class="type">K3</span>) -&gt; <span class="type">Bool</span><br/>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K3</span>, <span class="type">V3</span>&gt;</code></h4><p><p>Map product.</p>
<p>Conditional <em>catesian product</em>, where the given
operation <code>op</code> <em>conditionally</em> creates output elements in the
resulting trie.</p>
<p>The keyed structure of the input tries are not relevant for this
operation: all pairs are considered, regardless of keys matching or
not.  Moreover, the resulting trie may use keys that are unrelated to
these input keys.</p>
</p></div><div class="declaration"><h4 class="function" id="iter"><code><span class="keyword">public func </span><span class="fnname">iter</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <a href="Iter.html#type.Iter"><span class="type">I.Iter</span></a>&lt;(<span class="type">K</span>, <span class="type">V</span>)&gt;</code></h4><p><p>Returns an <code>Iter</code> over the key-value entries of the trie.</p>
<p>Each iterator gets a <em>persistent view</em> of the mapping, independent of concurrent updates to the iterated map.</p>
</p></div><div class="declaration"><h4 class="value-declaration" id="Build"><code><span class="keyword">public let </span><span class="fnname">Build</span> : </code></h4><p><p>Represent the construction of tries as data.</p>
<p>This module provides optimized variants of normal tries, for
more efficient join queries.</p>
<p>The central insight is that for (unmaterialized) join query results, we
do not need to actually build any resulting trie of the resulting
data, but rather, just need a collection of what would be in that
trie.  Since query results can be large (quadratic in the DB size),
avoiding the construction of this trie provides a considerable savings.</p>
<p>To get this savings, we use an ADT for the operations that <em>would</em> build this trie,
if evaluated. This structure specializes a rope: a balanced tree representing a
sequence.  It is only as balanced as the tries from which we generate
these build ASTs.  They have no intrinsic balance properties of their
own.</p>
</p></div><div class="declaration"><h4 class="function" id="fold"><code><span class="keyword">public func </span><span class="fnname">fold</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>, <span class="type">X</span>) -&gt; <span class="type">X</span>, <br/>  <span class="parameter">x</span> : <span class="type">X</span><br/>) : <span class="type">X</span></code></h4><p><p>Fold over the key-value pairs of the trie, using an accumulator.
The key-value pairs have no reliable or meaningful ordering.</p>
</p></div><div class="declaration"><h4 class="function" id="some"><code><span class="keyword">public func </span><span class="fnname">some</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Test whether a given key-value pair is present, or not.</p>
</p></div><div class="declaration"><h4 class="function" id="all"><code><span class="keyword">public func </span><span class="fnname">all</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Test whether all key-value pairs have a given property.</p>
</p></div><div class="declaration"><h4 class="function" id="nth"><code><span class="keyword">public func </span><span class="fnname">nth</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">i</span> : <span class="type">Nat</span>) : ?(<a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>)</code></h4><p><p>Project the nth key-value pair from the trie.</p>
<p>Note: This position is not meaningful; it's only here so that we
can inject tries into arrays using functions like <code>Array.tabulate</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="toArray"><code><span class="keyword">public func </span><span class="fnname">toArray</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">W</span>&gt;(<span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">W</span>) : [<span class="type">W</span>]</code></h4><p><p>Gather the collection of key-value pairs into an array of a (possibly-distinct) type.</p>
</p></div><div class="declaration"><h4 class="function" id="isEmpty"><code><span class="keyword">public func </span><span class="fnname">isEmpty</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <span class="type">Bool</span></code></h4><p><p>Test for &quot;deep emptiness&quot;: subtrees that have branching structure,
but no leaves.  These can result from naive filtering operations;
filter uses this function to avoid creating such subtrees.</p>
</p></div><div class="declaration"><h4 class="function" id="filter"><code><span class="keyword">public func </span><span class="fnname">filter</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Filter the key-value pairs by a given predicate.</p>
</p></div><div class="declaration"><h4 class="function" id="mapFilter"><code><span class="keyword">public func </span><span class="fnname">mapFilter</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">W</span>&gt;(<span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; ?<span class="type">W</span>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">W</span>&gt;</code></h4><p><p>Map and filter the key-value pairs by a given predicate.</p>
</p></div><div class="declaration"><h4 class="function" id="equalStructure"><code><span class="keyword">public func </span><span class="fnname">equalStructure</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">tl</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">keq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">veq</span> : (<span class="type">V</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Test for equality, but naively, based on structure.
Does not attempt to remove &quot;junk&quot; in the tree;
For instance, a &quot;smarter&quot; approach would equate
 <code>#bin {left = #empty; right = #empty}</code>
with
 <code>#empty</code>.
We do not observe that equality here.</p>
</p></div><div class="declaration"><h4 class="function" id="replaceThen"><code><span class="keyword">public func </span><span class="fnname">replaceThen</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v2</span> : <span class="type">V</span>, <br/>  <span class="parameter">success</span> : (<a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="type">V</span>) -&gt; <span class="type">X</span>, <br/>  <span class="parameter">fail</span> : () -&gt; <span class="type">X</span><br/>) : <span class="type">X</span></code></h4><p><p>Replace the given key's value in the trie,
and only if successful, do the success continuation,
otherwise, return the failure value</p>
</p></div><div class="declaration"><h4 class="function" id="putFresh"><code><span class="keyword">public func </span><span class="fnname">putFresh</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v</span> : <span class="type">V</span><br/>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Put the given key's value in the trie; return the new trie; assert that no prior value is associated with the key</p>
</p></div><div class="declaration"><h4 class="function" id="put2D"><code><span class="keyword">public func </span><span class="fnname">put2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie2D"><span class="type">Trie2D</span></a>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k1</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K1</span>&gt;, <br/>  <span class="parameter">k1_eq</span> : (<span class="type">K1</span>, <span class="type">K1</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k2</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K2</span>&gt;, <br/>  <span class="parameter">k2_eq</span> : (<span class="type">K2</span>, <span class="type">K2</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v</span> : <span class="type">V</span><br/>) : <a href="#type.Trie2D"><span class="type">Trie2D</span></a>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;</code></h4><p><p>Put the given key's value in the 2D trie; return the new 2D trie.</p>
</p></div><div class="declaration"><h4 class="function" id="put3D"><code><span class="keyword">public func </span><span class="fnname">put3D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie3D"><span class="type">Trie3D</span></a>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k1</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K1</span>&gt;, <br/>  <span class="parameter">k1_eq</span> : (<span class="type">K1</span>, <span class="type">K1</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k2</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K2</span>&gt;, <br/>  <span class="parameter">k2_eq</span> : (<span class="type">K2</span>, <span class="type">K2</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k3</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K3</span>&gt;, <br/>  <span class="parameter">k3_eq</span> : (<span class="type">K3</span>, <span class="type">K3</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v</span> : <span class="type">V</span><br/>) : <a href="#type.Trie3D"><span class="type">Trie3D</span></a>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;</code></h4><p><p>Put the given key's value in the trie; return the new trie;</p>
</p></div><div class="declaration"><h4 class="function" id="remove"><code><span class="keyword">public func </span><span class="fnname">remove</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span><br/>) : (<a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p><p>Remove the given key's value in the trie; return the new trie</p>
</p></div><div class="declaration"><h4 class="function" id="removeThen"><code><span class="keyword">public func </span><span class="fnname">removeThen</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">success</span> : (<a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="type">V</span>) -&gt; <span class="type">X</span>, <br/>  <span class="parameter">fail</span> : () -&gt; <span class="type">X</span><br/>) : <span class="type">X</span></code></h4><p><p>Remove the given key's value in the trie,
and only if successful, do the success continuation,
otherwise, return the failure value</p>
</p></div><div class="declaration"><h4 class="function" id="remove2D"><code><span class="keyword">public func </span><span class="fnname">remove2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie2D"><span class="type">Trie2D</span></a>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k1</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K1</span>&gt;, <br/>  <span class="parameter">k1_eq</span> : (<span class="type">K1</span>, <span class="type">K1</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k2</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K2</span>&gt;, <br/>  <span class="parameter">k2_eq</span> : (<span class="type">K2</span>, <span class="type">K2</span>) -&gt; <span class="type">Bool</span><br/>) : (<a href="#type.Trie2D"><span class="type">Trie2D</span></a>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p><p>remove the given key-key pair's value in the 2D trie; return the
new trie, and the prior value, if any.</p>
</p></div><div class="declaration"><h4 class="function" id="remove3D"><code><span class="keyword">public func </span><span class="fnname">remove3D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie3D"><span class="type">Trie3D</span></a>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k1</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K1</span>&gt;, <br/>  <span class="parameter">k1_eq</span> : (<span class="type">K1</span>, <span class="type">K1</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k2</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K2</span>&gt;, <br/>  <span class="parameter">k2_eq</span> : (<span class="type">K2</span>, <span class="type">K2</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k3</span> : <a href="#type.Key"><span class="type">Key</span></a>&lt;<span class="type">K3</span>&gt;, <br/>  <span class="parameter">k3_eq</span> : (<span class="type">K3</span>, <span class="type">K3</span>) -&gt; <span class="type">Bool</span><br/>) : (<a href="#type.Trie3D"><span class="type">Trie3D</span></a>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p><p>Remove the given key-key pair's value in the 3D trie; return the
new trie, and the prior value, if any.</p>
</p></div><div class="declaration"><h4 class="function" id="mergeDisjoint2D"><code><span class="keyword">public func </span><span class="fnname">mergeDisjoint2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <a href="#type.Trie2D"><span class="type">Trie2D</span></a>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k1_eq</span> : (<span class="type">K1</span>, <span class="type">K1</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k2_eq</span> : (<span class="type">K2</span>, <span class="type">K2</span>) -&gt; <span class="type">Bool</span><br/>) : <a href="#type.Trie"><span class="type">Trie</span></a>&lt;<span class="type">K2</span>, <span class="type">V</span>&gt;</code></h4><p><p>Like <a href="#mergedisjoint"><code>mergeDisjoint</code></a>, except instead of merging a
pair, it merges the collection of dimension-2 sub-trees of a 2D
trie.</p>
</p></div></div></body></html>